use crate::models::{DartClass, DartField, DartType};

pub struct RustGenerator {
    include_helpers: bool,
}

impl RustGenerator {
    pub fn new() -> Self {
        Self {
            include_helpers: true,
        }
    }

    pub fn generate_all(&self, classes: &[DartClass]) -> String {
        let mut output = String::new();

        output.push_str("// Auto-generated by dart_json_gen\n");
        output.push_str("// Do not edit manually\n\n");
        output.push_str("use serde::{Deserialize, Serialize};\n");
        
        let needs_hashmap = classes.iter().any(|c| {
            c.fields.iter().any(|f| matches!(f.dart_type, DartType::Map(_, _)))
        });
        let needs_hashset = classes.iter().any(|c| {
            c.fields.iter().any(|f| matches!(f.dart_type, DartType::Set(_)))
        });
        
        if needs_hashmap || needs_hashset {
            output.push_str("use std::collections::{");
            let mut parts = Vec::new();
            if needs_hashmap { parts.push("HashMap"); }
            if needs_hashset { parts.push("HashSet"); }
            output.push_str(&parts.join(", "));
            output.push_str("};\n");
        }
        
        output.push_str("\n");

        for class in classes {
            output.push_str(&self.generate_struct(class));
            output.push_str("\n");
        }

        if self.include_helpers {
            output.push_str(&self.generate_helpers(classes));
        }

        output
    }

    pub fn generate_single(&self, class: &DartClass) -> String {
        let mut output = String::new();

        output.push_str("// Auto-generated by dart_json_gen\n");
        output.push_str("// Do not edit manually\n\n");
        output.push_str("use serde::{Deserialize, Serialize};\n");
        
        let needs_hashmap = class.fields.iter().any(|f| matches!(f.dart_type, DartType::Map(_, _)));
        let needs_hashset = class.fields.iter().any(|f| matches!(f.dart_type, DartType::Set(_)));
        
        if needs_hashmap || needs_hashset {
            output.push_str("use std::collections::{");
            let mut parts = Vec::new();
            if needs_hashmap { parts.push("HashMap"); }
            if needs_hashset { parts.push("HashSet"); }
            output.push_str(&parts.join(", "));
            output.push_str("};\n");
        }
        
        output.push_str("\n");

        output.push_str(&self.generate_struct(class));

        if self.include_helpers {
            output.push_str("\n");
            output.push_str(&self.generate_struct_helpers(class));
        }

        output
    }

    fn generate_struct(&self, class: &DartClass) -> String {
        let mut output = String::new();

        output.push_str(&format!("/// Generated from: {}\n", class.source_file));
        output.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        
        if let Some(naming) = &class.naming_convention {
            output.push_str(&format!(
                "#[serde(rename_all = \"{}\")]\n",
                naming.to_serde_attr()
            ));
        }
        
        output.push_str(&format!("pub struct {} {{\n", class.name));

        for field in &class.fields {
            output.push_str(&self.generate_field(field));
        }

        output.push_str("}\n");

        output
    }

    fn generate_field(&self, field: &DartField) -> String {
        if field.ignore_json {
            return String::new();
        }

        let mut output = String::new();
        let mut attrs = Vec::new();

        if let Some(ref key) = field.json_key {
            attrs.push(format!("rename = \"{}\"", key));
        }

        if let Some(ref naming) = field.naming_convention {
            attrs.push(format!("rename_all = \"{}\"", naming.to_serde_attr()));
        }


        if field.is_nullable && !field.include_if_null {
            attrs.push("skip_serializing_if = \"Option::is_none\"".to_string());
            attrs.push("default".to_string());
        } else if field.is_nullable && field.include_if_null {
            attrs.push("default".to_string());
        }

        if field.has_default && !field.is_nullable {
            attrs.push("default".to_string());
        }

        if !attrs.is_empty() {
            output.push_str(&format!("    #[serde({})]\n", attrs.join(", ")));
        }

        let rust_type = if field.is_nullable && !matches!(field.dart_type, DartType::Optional(_)) {
            format!("Option<{}>", field.dart_type.to_rust_type())
        } else {
            field.dart_type.to_rust_type()
        };

        let rust_field_name = to_snake_case(&field.name);

        output.push_str(&format!("    pub {}: {},\n", rust_field_name, rust_type));

        output
    }

    fn generate_helpers(&self, classes: &[DartClass]) -> String {
        let mut output = String::new();

        output.push_str("// ============ Serialization Helpers ============\n\n");

        for class in classes {
            output.push_str(&self.generate_struct_helpers(class));
            output.push_str("\n");
        }

        output
    }

    fn generate_struct_helpers(&self, class: &DartClass) -> String {
        let mut output = String::new();
        let name = &class.name;
        let snake_name = to_snake_case(name);

        output.push_str(&format!(
            r#"/// Parse JSON string into {name}
pub fn parse_{snake_name}(json: &str) -> Result<{name}, serde_json::Error> {{
    serde_json::from_str(json)
}}

/// Parse JSON string into Vec<{name}>
pub fn parse_{snake_name}_list(json: &str) -> Result<Vec<{name}>, serde_json::Error> {{
    serde_json::from_str(json)
}}

/// Serialize {name} to JSON string
pub fn {snake_name}_to_json(value: &{name}) -> Result<String, serde_json::Error> {{
    serde_json::to_string(value)
}}

/// Serialize {name} to pretty JSON string
pub fn {snake_name}_to_json_pretty(value: &{name}) -> Result<String, serde_json::Error> {{
    serde_json::to_string_pretty(value)
}}

"#
        ));

        output
    }

    pub fn generate_mod_file(&self, classes: &[DartClass]) -> String {
        let mut output = String::new();

        output.push_str("// Auto-generated by dart_json_gen\n");
        output.push_str("// Do not edit manually\n\n");

        for class in classes {
            let module_name = to_snake_case(&class.name);
            output.push_str(&format!("mod {};\n", module_name));
        }

        output.push_str("\n");

        for class in classes {
            let module_name = to_snake_case(&class.name);
            output.push_str(&format!("pub use {}::*;\n", module_name));
        }

        output
    }
}

impl Default for RustGenerator {
    fn default() -> Self {
        Self::new()
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

