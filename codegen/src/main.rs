mod parser;
mod generator;
mod models;

use anyhow::Result;
use clap::Parser;
use colored::Colorize;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::path::PathBuf;
use walkdir::WalkDir;

use crate::parser::DartParser;

fn calculate_checksum(content: &str) -> u64 {
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    hasher.finish()
}

fn extract_checksum(content: &str) -> Option<u64> {
    for line in content.lines().take(5) {
        if line.starts_with("// Checksum: ") {
            return line.strip_prefix("// Checksum: ")?.parse().ok();
        }
    }
    None
}

#[derive(Parser, Debug)]
#[command(name = "dart_json_gen")]
#[command(about = "Generate Dart serializers, copyWith, equatable from annotated models")]
struct Args {
    #[arg(short, long)]
    input: PathBuf,
    #[arg(long, default_value_t = false)]
    rust: bool,
    #[arg(long, default_value = "rust_gen")]
    rust_output: PathBuf,
    #[arg(long, default_value_t = false)]
    single_file: bool,
    #[arg(short, long)]
    output: Option<PathBuf>,
    #[arg(short, long, default_value_t = false)]
    verbose: bool,
}

fn main() -> Result<()> {
    let args = Args::parse();
    println!("{}", "ðŸ¦€ Dart Code Generator".green().bold());
    println!("Input: {}", args.input.display().to_string().cyan());
    println!("Output: {}", "alongside source files".cyan());
    if args.rust { println!("Rust Output: {}", args.rust_output.display().to_string().cyan()); }
    println!();

    let dart_files = collect_dart_files(&args.input)?;
    if dart_files.is_empty() { println!("{}", "No .dart files found!".yellow()); return Ok(()); }
    println!("Found {} .dart file(s)", dart_files.len().to_string().green());

    let parser = DartParser::new();
    let mut all_classes = Vec::new();
    let mut files_with_classes: Vec<(PathBuf, Vec<models::DartClass>)> = Vec::new();
    let mut files_without_classes: Vec<PathBuf> = Vec::new();

    for file_path in &dart_files {
        if args.verbose { println!("  Parsing: {}", file_path.display()); }
        let content = std::fs::read_to_string(file_path)?;
        let classes = parser.parse(&content, file_path)?;
        if !classes.is_empty() {
            let mut file_classes = Vec::new();
            for class in classes {
                let features = format_features(&class.features);
                println!("  {} {} ({} fields) {}", "âœ“".green(), class.name.cyan(), class.fields.len(), features.dimmed());
                file_classes.push(class.clone());
                all_classes.push(class);
            }
            files_with_classes.push((file_path.clone(), file_classes));
        } else {
            files_without_classes.push(file_path.clone());
        }
    }

    let mut cleaned_count = 0;
    for source_path in &files_without_classes {
        let gen_path = get_gen_path(source_path);
        if gen_path.exists() {
            std::fs::remove_file(&gen_path)?;
            println!("  {} {} (no annotations)", "ðŸ—‘".red(), gen_path.display().to_string().yellow());
            cleaned_count += 1;
        }
    }
    if cleaned_count > 0 { println!("Cleaned {} orphaned .gen.dart file(s)", cleaned_count.to_string().yellow()); }
    if all_classes.is_empty() { println!("{}", "No annotated classes found!".yellow()); return Ok(()); }

    println!();
    println!("Found {} annotated class(es)", all_classes.len().to_string().green());
    println!();
    println!("{}", "Generating Dart code...".blue());

    if args.single_file {
        let output_dir = args.output.clone().unwrap_or_else(|| args.input.parent().unwrap_or(&args.input).to_path_buf());
        std::fs::create_dir_all(&output_dir)?;
        let mut dart_code = String::new();
        dart_code.push_str("// GENERATED CODE - DO NOT MODIFY BY HAND\n// Generated by: dart_json_gen (Rust)\n\nimport 'dart:convert';\n\n");
        for (source_path, _) in &files_with_classes {
            let source_name = source_path.file_name().and_then(|n| n.to_str()).unwrap_or("model.dart");
            dart_code.push_str(&format!("import '{}';\n", source_name));
        }
        dart_code.push_str("\n");
        let needs_deep_equals = all_classes.iter().any(|c| c.features.equatable && c.fields.iter().any(|f| !f.ignore_equality && matches!(f.dart_type, models::DartType::List(_) | models::DartType::Map(_, _) | models::DartType::Set(_))));
        for class in &all_classes { dart_code.push_str(&generate_class_code(class)); dart_code.push_str("\n"); }
        if needs_deep_equals { dart_code.push_str(&generate_deep_equals_helper()); }
        let output_path = output_dir.join("models.gen.dart");
        std::fs::write(&output_path, dart_code)?;
        println!("  {} {}", "â†’".green(), output_path.display().to_string().cyan());
    } else {
        for (source_path, classes) in &files_with_classes {
            let gen_path = get_gen_path(source_path);
            let source_name = source_path.file_stem().and_then(|n| n.to_str()).unwrap_or("model");
            let source_content = std::fs::read_to_string(source_path)?;
            let source_checksum = calculate_checksum(&source_content);
            if gen_path.exists() {
                if let Ok(existing_content) = std::fs::read_to_string(&gen_path) {
                    if let Some(existing_checksum) = extract_checksum(&existing_content) {
                        if existing_checksum == source_checksum {
                            println!("  {} {} (unchanged)", "â­".dimmed(), gen_path.display().to_string().dimmed());
                            continue;
                        }
                    }
                }
            }
            
            // Check if this is a part file and get the main library to import
            let import_file = if let Some(part_of_target) = extract_part_of(&source_content) {
                // Remove .dart extension if present, then add it back
                let target = part_of_target.trim_end_matches(".dart");
                format!("{}.dart", target)
            } else {
                format!("{}.dart", source_name)
            };
            
            let mut dart_code = String::new();
            dart_code.push_str("// GENERATED CODE - DO NOT MODIFY BY HAND\n// Generated by: dart_json_gen (Rust)\n");
            dart_code.push_str(&format!("// Checksum: {}\n\nimport 'dart:convert';\nimport '{}';\n\n", source_checksum, import_file));
            let needs_deep_equals = classes.iter().any(|c| c.features.equatable && c.fields.iter().any(|f| !f.ignore_equality && matches!(f.dart_type, models::DartType::List(_) | models::DartType::Map(_, _) | models::DartType::Set(_))));
            for class in classes { dart_code.push_str(&generate_class_code(class)); dart_code.push_str("\n"); }
            if needs_deep_equals { dart_code.push_str(&generate_deep_equals_helper()); }
            std::fs::write(&gen_path, dart_code)?;
            println!("  {} {}", "â†’".green(), gen_path.display().to_string().cyan());
        }
    }

    if args.rust {
        println!();
        println!("{}", "Generating Rust structs...".blue());
        let rust_generator = generator::RustGenerator::new();
        std::fs::create_dir_all(&args.rust_output)?;
        if args.single_file {
            let rust_code = rust_generator.generate_all(&all_classes);
            let output_path = args.rust_output.join("models.rs");
            std::fs::write(&output_path, rust_code)?;
            println!("  {} {}", "â†’".green(), output_path.display().to_string().cyan());
        } else {
            for class in &all_classes {
                let rust_code = rust_generator.generate_single(class);
                let file_name = to_snake_case(&class.name) + ".rs";
                let output_path = args.rust_output.join(&file_name);
                std::fs::write(&output_path, rust_code)?;
                println!("  {} {}", "â†’".green(), output_path.display().to_string().cyan());
            }
            let mod_content = rust_generator.generate_mod_file(&all_classes);
            let mod_path = args.rust_output.join("mod.rs");
            std::fs::write(&mod_path, mod_content)?;
            println!("  {} {}", "â†’".green(), mod_path.display().to_string().cyan());
        }
    }
    println!();
    println!("{}", "âœ… Generation complete!".green().bold());
    Ok(())
}

fn format_features(features: &models::GenerationFeatures) -> String {
    let mut parts = Vec::new();
    if features.json { parts.push("json"); }
    if features.copy_with { parts.push("copyWith"); }
    if features.equatable { parts.push("=="); }
    if features.stringify { parts.push("toString"); }
    if parts.is_empty() { String::new() } else { format!("[{}]", parts.join(", ")) }
}

fn get_gen_path(source_path: &PathBuf) -> PathBuf {
    let parent = source_path.parent().unwrap_or(source_path);
    let stem = source_path.file_stem().and_then(|s| s.to_str()).unwrap_or("model");
    parent.join(format!("{}.gen.dart", stem))
}

fn collect_dart_files(path: &PathBuf) -> Result<Vec<PathBuf>> {
    let mut files = Vec::new();
    if path.is_file() {
        if path.extension().map_or(false, |ext| ext == "dart") && !path.to_string_lossy().ends_with(".gen.dart") && !path.to_string_lossy().ends_with(".g.dart") {
            files.push(path.clone());
        }
    } else if path.is_dir() {
        for entry in WalkDir::new(path).into_iter().filter_map(|e| e.ok()).filter(|e| e.path().extension().map_or(false, |ext| ext == "dart")).filter(|e| !e.path().to_string_lossy().ends_with(".gen.dart")).filter(|e| !e.path().to_string_lossy().ends_with(".g.dart")) {
            files.push(entry.path().to_path_buf());
        }
    }
    Ok(files)
}

/// Extract the `part of` target file from a Dart file content
/// Returns Some(filename) if file is a part file, None otherwise
fn extract_part_of(content: &str) -> Option<String> {
    use regex::Regex;
    let part_of_re = Regex::new(r#"part\s+of\s+['"]([^'"]+)['"]"#).unwrap();
    part_of_re.captures(content).and_then(|cap| cap.get(1).map(|m| m.as_str().to_string()))
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() { if i > 0 { result.push('_'); } result.push(c.to_lowercase().next().unwrap()); } else { result.push(c); }
    }
    result
}

fn generate_class_code(class: &models::DartClass) -> String {
    let mut output = String::new();
    if class.features.json { output.push_str(&generate_json_extension(class)); output.push_str(&generate_serializer_class(class)); }
    if class.features.copy_with { output.push_str(&generate_copy_with(class)); }
    if class.features.equatable { output.push_str(&generate_equatable(class)); }
    if class.features.stringify { output.push_str(&generate_to_string(class)); }
    output
}

fn generate_deep_equals_helper() -> String {
    r#"bool _deepEquals(dynamic a, dynamic b) {
  if (identical(a, b)) return true;
  if (a is List && b is List) { if (a.length != b.length) return false; for (var i = 0; i < a.length; i++) { if (!_deepEquals(a[i], b[i])) return false; } return true; }
  if (a is Map && b is Map) { if (a.length != b.length) return false; for (final key in a.keys) { if (!b.containsKey(key) || !_deepEquals(a[key], b[key])) return false; } return true; }
  if (a is Set && b is Set) { if (a.length != b.length) return false; return a.containsAll(b); }
  return a == b;
}
"#.to_string()
}

fn generate_json_extension(class: &models::DartClass) -> String {
    let mut output = String::new();
    let name = &class.name;
    output.push_str(&format!("extension ${}JsonExtension on {} {{\n  Map<String, dynamic> toJson() {{\n    return <String, dynamic>{{\n", name, name));
    for field in &class.fields {
        if field.ignore { continue; }
        let json_key = get_json_key(field, class.naming_convention.as_ref());
        let value_expr = field_to_json_expr(field);
        if field.is_nullable && !field.include_if_null {
            output.push_str(&format!("      if ({} != null) '{}': {},\n", field.name, json_key, value_expr));
        } else {
            output.push_str(&format!("      '{}': {},\n", json_key, value_expr));
        }
    }
    output.push_str("    };\n  }\n\n  String toJsonString() => jsonEncode(toJson());\n}\n\n");
    output
}

fn generate_serializer_class(class: &models::DartClass) -> String {
    let mut output = String::new();
    let name = &class.name;
    output.push_str(&format!("class ${}Serializer {{\n  static {} fromJson(Map<String, dynamic> json) {{\n    return {}(\n", name, name, name));
    let non_ignored_fields: Vec<_> = class.fields.iter().filter(|f| !f.ignore).collect();
    for (i, field) in non_ignored_fields.iter().enumerate() {
        let json_key = get_json_key(field, class.naming_convention.as_ref());
        let value_expr = field_from_json_expr(field, &json_key);
        if class.uses_named_params { output.push_str(&format!("      {}: {},\n", field.name, value_expr)); }
        else { let comma = if i < non_ignored_fields.len() - 1 { "," } else { "" }; output.push_str(&format!("      {}{}\n", value_expr, comma)); }
    }
    output.push_str(&format!("    );\n  }}\n\n  static {} fromJsonString(String json) => fromJson(jsonDecode(json) as Map<String, dynamic>);\n  static List<{}> fromJsonList(List<dynamic> jsonList) => jsonList.map((e) => fromJson(e as Map<String, dynamic>)).toList();\n  static List<{}> fromJsonStringList(String json) => fromJsonList(jsonDecode(json) as List<dynamic>);\n}}\n\n", name, name, name));
    output
}

fn generate_copy_with(class: &models::DartClass) -> String {
    let mut output = String::new();
    let name = &class.name;
    let uses_named = class.uses_named_params;
    let copy_fields: Vec<_> = class.fields.iter().filter(|f| !f.ignore_copy_with).collect();
    output.push_str(&format!("extension ${}CopyWithExtension on {} {{\n  {} copyWith({{\n", name, name, name));
    for field in &copy_fields { output.push_str(&format!("    {}? {},\n", field.dart_type.to_dart_type(), field.name)); }
    output.push_str(&format!("  }}) {{\n    return {}(\n", name));
    if uses_named {
        for field in &class.fields {
            if field.ignore_copy_with { output.push_str(&format!("      {}: this.{},\n", field.name, field.name)); }
            else { output.push_str(&format!("      {}: {} ?? this.{},\n", field.name, field.name, field.name)); }
        }
    } else {
        for field in &class.fields {
            if field.ignore_copy_with { output.push_str(&format!("      this.{},\n", field.name)); }
            else { output.push_str(&format!("      {} ?? this.{},\n", field.name, field.name)); }
        }
    }
    output.push_str("    );\n  }\n");
    if class.features.copy_with_null {
        let nullable_fields: Vec<_> = copy_fields.iter().filter(|f| f.is_nullable).collect();
        if !nullable_fields.is_empty() {
            output.push_str(&format!("\n  {} copyWithNull({{\n", name));
            for field in &nullable_fields { output.push_str(&format!("    bool {} = false,\n", field.name)); }
            output.push_str(&format!("  }}) {{\n    return {}(\n", name));
            if uses_named {
                for field in &class.fields {
                    if field.ignore_copy_with { output.push_str(&format!("      {}: this.{},\n", field.name, field.name)); }
                    else if field.is_nullable { output.push_str(&format!("      {}: {} ? null : this.{},\n", field.name, field.name, field.name)); }
                    else { output.push_str(&format!("      {}: this.{},\n", field.name, field.name)); }
                }
            } else {
                for field in &class.fields {
                    if field.ignore_copy_with { output.push_str(&format!("      this.{},\n", field.name)); }
                    else if field.is_nullable { output.push_str(&format!("      {} ? null : this.{},\n", field.name, field.name)); }
                    else { output.push_str(&format!("      this.{},\n", field.name)); }
                }
            }
            output.push_str("    );\n  }\n");
        }
    }
    output.push_str("}\n\n");
    output
}

fn generate_equatable(class: &models::DartClass) -> String {
    let mut output = String::new();
    let name = &class.name;
    let eq_fields: Vec<_> = class.fields.iter().filter(|f| !f.ignore_equality).collect();
    output.push_str(&format!("extension ${}EquatableExtension on {} {{\n  List<Object?> get props => [\n", name, name));
    for field in &eq_fields { output.push_str(&format!("    {},\n", field.name)); }
    output.push_str(&format!("  ];\n\n  bool equals({} other) {{\n", name));
    if eq_fields.is_empty() { output.push_str("    return true;\n"); }
    else {
        output.push_str("    return ");
        let conditions: Vec<String> = eq_fields.iter().map(|f| {
            match &f.dart_type {
                models::DartType::List(_) | models::DartType::Map(_, _) | models::DartType::Set(_) => format!("_deepEquals({}, other.{})", f.name, f.name),
                _ => format!("{} == other.{}", f.name, f.name)
            }
        }).collect();
        output.push_str(&conditions.join(" &&\n        "));
        output.push_str(";\n");
    }
    output.push_str("  }\n\n  int get propsHashCode {\n");
    if eq_fields.is_empty() { output.push_str("    return 0;\n"); } else { output.push_str("    return Object.hashAll(props);\n"); }
    output.push_str("  }\n}\n\n");
    output
}

fn generate_to_string(class: &models::DartClass) -> String {
    let mut output = String::new();
    let name = &class.name;
    let str_fields: Vec<_> = class.fields.iter().filter(|f| !f.ignore_to_string).collect();
    output.push_str(&format!("extension ${}StringExtension on {} {{\n  String toStringRepresentation() {{\n", name, name));
    let field_strs: Vec<String> = str_fields.iter().map(|f| format!("{}: ${}", f.name, f.name)).collect();
    output.push_str(&format!("    return '{}({})';\n  }}\n}}\n\n", name, field_strs.join(", ")));
    output
}

fn get_json_key(field: &models::DartField, class_convention: Option<&models::NamingConvention>) -> String {
    if let Some(ref key) = field.json_key { return key.clone(); }
    let convention = field.naming_convention.as_ref().or(class_convention);
    if let Some(conv) = convention { return convert_case(&field.name, conv); }
    field.name.clone()
}

fn convert_case(s: &str, convention: &models::NamingConvention) -> String {
    match convention {
        models::NamingConvention::SnakeCase => to_snake_case(s),
        models::NamingConvention::CamelCase => s.to_string(),
        models::NamingConvention::PascalCase => { let mut chars = s.chars(); match chars.next() { None => String::new(), Some(first) => first.to_uppercase().collect::<String>() + chars.as_str() } }
        models::NamingConvention::ScreamingSnakeCase => to_snake_case(s).to_uppercase(),
    }
}

fn field_to_json_expr(field: &models::DartField) -> String {
    let name = &field.name;
    match &field.dart_type {
        models::DartType::DateTime => if field.is_nullable { format!("{}?.toIso8601String()", name) } else { format!("{}.toIso8601String()", name) },
        models::DartType::List(inner) => if needs_mapping(inner) { if field.is_nullable { format!("{}?.map((e) => e.toJson()).toList()", name) } else { format!("{}.map((e) => e.toJson()).toList()", name) } } else { name.clone() },
        models::DartType::Custom(_) => if field.is_nullable { format!("{}?.toJson()", name) } else { format!("{}.toJson()", name) },
        _ => name.clone(),
    }
}

fn needs_mapping(dart_type: &models::DartType) -> bool { matches!(dart_type, models::DartType::Custom(_) | models::DartType::DateTime) }

fn field_from_json_expr(field: &models::DartField, json_key: &str) -> String {
    let accessor = format!("json['{}']", json_key);
    match &field.dart_type {
        models::DartType::String => if field.is_nullable { format!("{} as String?", accessor) } else { format!("{} as String", accessor) },
        models::DartType::Int => if field.is_nullable { format!("({} as num?)?.toInt()", accessor) } else { format!("({} as num).toInt()", accessor) },
        models::DartType::Double | models::DartType::Num => if field.is_nullable { format!("({} as num?)?.toDouble()", accessor) } else { format!("({} as num).toDouble()", accessor) },
        models::DartType::Bool => if field.is_nullable { format!("{} as bool?", accessor) } else { format!("{} as bool", accessor) },
        models::DartType::DateTime => if field.is_nullable { format!("{} != null ? DateTime.parse({} as String) : null", accessor, accessor) } else { format!("DateTime.parse({} as String)", accessor) },
        models::DartType::List(inner) => { let inner_expr = list_item_from_json(inner); if field.is_nullable { format!("({} as List<dynamic>?)?.map((e) => {}).toList()", accessor, inner_expr) } else { format!("({} as List<dynamic>).map((e) => {}).toList()", accessor, inner_expr) } },
        models::DartType::Map(key_type, value_type) => { let key_dart = key_type.to_dart_type(); let value_dart = value_type.to_dart_type(); if value_type.is_dynamic() { if field.is_nullable { format!("{} as Map<{}, {}>?", accessor, key_dart, value_dart) } else { format!("{} as Map<{}, {}>", accessor, key_dart, value_dart) } } else { let value_cast = map_value_cast(value_type); if field.is_nullable { format!("({} as Map<String, dynamic>?)?.map((k, v) => MapEntry(k, {}))", accessor, value_cast) } else { format!("({} as Map<String, dynamic>).map((k, v) => MapEntry(k, {}))", accessor, value_cast) } } },
        models::DartType::Custom(type_name) => if field.is_nullable { format!("{} != null ? ${}Serializer.fromJson({} as Map<String, dynamic>) : null", accessor, type_name, accessor) } else { format!("${}Serializer.fromJson({} as Map<String, dynamic>)", type_name, accessor) },
        models::DartType::Dynamic => accessor,
        _ => accessor,
    }
}

fn map_value_cast(value_type: &models::DartType) -> String {
    match value_type {
        models::DartType::String => "v as String".to_string(),
        models::DartType::Int => "(v as num).toInt()".to_string(),
        models::DartType::Double | models::DartType::Num => "(v as num).toDouble()".to_string(),
        models::DartType::Bool => "v as bool".to_string(),
        models::DartType::Custom(type_name) => format!("${}Serializer.fromJson(v as Map<String, dynamic>)", type_name),
        _ => "v".to_string(),
    }
}

fn list_item_from_json(inner: &models::DartType) -> String {
    match inner {
        models::DartType::String => "e as String".to_string(),
        models::DartType::Int => "(e as num).toInt()".to_string(),
        models::DartType::Double | models::DartType::Num => "(e as num).toDouble()".to_string(),
        models::DartType::Bool => "e as bool".to_string(),
        models::DartType::DateTime => "DateTime.parse(e as String)".to_string(),
        models::DartType::Custom(type_name) => format!("${}Serializer.fromJson(e as Map<String, dynamic>)", type_name),
        _ => "e".to_string(),
    }
}

